This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-23T16:46:37.503Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.github/
  workflows/
    build.yml
gradle/
  wrapper/
    gradle-wrapper.properties
src/
  main/
    java/
      com/
        claude/
          commands/
            CommandHandler.java
          config/
            ModConfig.java
          mixin/
            ClientNetworkHandlerMixin.java
          pathfinding/
            BaritoneIntegration.java
            TeleportPathExecutor.java
          ui/
            TeleportHud.java
          world/
            ChunkLoadingTracker.java
          Zipline.java
    resources/
      fabric.mod.json
      zipline.mixins.json
.gitattributes
.gitignore
build.gradle
gradle.properties
gradlew
gradlew.bat
LICENSE
settings.gradle

================================================================
Repository Files
================================================================

================
File: .github/workflows/build.yml
================
# Automatically build the project and run any configured tests for every push
# and submitted pull request. This can help catch issues that only occur on
# certain platforms or Java versions, and provides a first line of defence
# against bad commits.

name: build
on: [pull_request, push]

jobs:
  build:
    runs-on: ubuntu-24.04
    steps:
      - name: checkout repository
        uses: actions/checkout@v4
      - name: validate gradle wrapper
        uses: gradle/actions/wrapper-validation@v4
      - name: setup jdk
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'microsoft'
      - name: make gradle wrapper executable
        run: chmod +x ./gradlew
      - name: build
        run: ./gradlew build
      - name: capture build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Artifacts
          path: build/libs/

================
File: gradle/wrapper/gradle-wrapper.properties
================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12.1-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

================
File: src/main/java/com/claude/commands/CommandHandler.java
================
// src/main/java/com/claude/commands/CommandHandler.java
package com.claude.commands;

import com.claude.Zipline;
import com.claude.pathfinding.BaritoneIntegration;
import com.mojang.brigadier.CommandDispatcher;
import com.mojang.brigadier.arguments.BoolArgumentType;
import com.mojang.brigadier.arguments.DoubleArgumentType;
import com.mojang.brigadier.arguments.IntegerArgumentType;
import net.fabricmc.fabric.api.client.command.v2.ClientCommandManager;
import net.fabricmc.fabric.api.client.command.v2.ClientCommandRegistrationCallback;
import net.fabricmc.fabric.api.client.command.v2.FabricClientCommandSource;
import net.minecraft.command.argument.BlockPosArgumentType;
import net.minecraft.text.Text;
import net.minecraft.util.math.BlockPos;

import java.util.List;
import java.util.concurrent.CompletableFuture;

public class CommandHandler {
    private final BaritoneIntegration baritoneIntegration;

    public CommandHandler() {
        this.baritoneIntegration = new BaritoneIntegration();
        registerCommands();
    }

    private void registerCommands() {
        ClientCommandRegistrationCallback.EVENT.register((dispatcher, registryAccess) -> {
            registerTeleportCommand(dispatcher);
            registerConfigCommands(dispatcher);
        });
    }

    private void registerTeleportCommand(CommandDispatcher<FabricClientCommandSource> dispatcher) {
        dispatcher.register(ClientCommandManager.literal("zipline")
                .then(ClientCommandManager.literal("goto")
                        .then(ClientCommandManager.argument("pos", BlockPosArgumentType.blockPos())
                                .executes(context -> {
                                    BlockPos targetPos = BlockPosArgumentType.getBlockPos(context, "pos");
                                    executePathfinding(targetPos, context.getSource());
                                    return 1;
                                })
                        )
                )
                .then(ClientCommandManager.literal("stop")
                        .executes(context -> {
                            if (Zipline.EXECUTOR.isExecuting()) {
                                Zipline.EXECUTOR.stopExecution();
                                context.getSource().sendFeedback(Text.literal("§aStopped teleport pathfinding"));
                            } else {
                                context.getSource().sendFeedback(Text.literal("§cNo active teleport pathfinding to stop"));
                            }
                            return 1;
                        })
                )
        );
    }

    private void registerConfigCommands(CommandDispatcher<FabricClientCommandSource> dispatcher) {
        dispatcher.register(ClientCommandManager.literal("zipline")
                .then(ClientCommandManager.literal("config")
                        .then(ClientCommandManager.literal("teleport")
                                .then(ClientCommandManager.argument("enabled", BoolArgumentType.bool())
                                        .executes(context -> {
                                            boolean enabled = BoolArgumentType.getBool(context, "enabled");
                                            Zipline.CONFIG.useTeleportation = enabled;
                                            context.getSource().sendFeedback(Text.literal("§aTeleportation " + (enabled ? "enabled" : "disabled")));
                                            return 1;
                                        })
                                )
                        )
                        .then(ClientCommandManager.literal("maxdistance")
                                .then(ClientCommandManager.argument("blocks", DoubleArgumentType.doubleArg(0.1, 100))
                                        .executes(context -> {
                                            double blocks = DoubleArgumentType.getDouble(context, "blocks");
                                            Zipline.CONFIG.maxDistancePerPacket = blocks;
                                            context.getSource().sendFeedback(Text.literal("§aMax distance per packet set to " + blocks + " blocks"));
                                            return 1;
                                        })
                                )
                        )
                        .then(ClientCommandManager.literal("packetdelay")
                                .then(ClientCommandManager.argument("ms", IntegerArgumentType.integer(0, 5000))
                                        .executes(context -> {
                                            int ms = IntegerArgumentType.getInteger(context, "ms");
                                            Zipline.CONFIG.packetDelayMs = ms;
                                            context.getSource().sendFeedback(Text.literal("§aPacket delay set to " + ms + "ms"));
                                            return 1;
                                        })
                                )
                        )
                        .then(ClientCommandManager.literal("chunkpoll")
                                .then(ClientCommandManager.argument("ms", IntegerArgumentType.integer(50, 10000))
                                        .executes(context -> {
                                            int ms = IntegerArgumentType.getInteger(context, "ms");
                                            Zipline.CONFIG.chunkLoadPollIntervalMs = ms;
                                            context.getSource().sendFeedback(Text.literal("§aChunk poll interval set to " + ms + "ms"));
                                            return 1;
                                        })
                                )
                        )
                        .then(ClientCommandManager.literal("status")
                                .executes(context -> {
                                    context.getSource().sendFeedback(Text.literal("§a--- Zipline Configuration ---"));
                                    context.getSource().sendFeedback(Text.literal("§7Teleportation: " +
                                            (Zipline.CONFIG.useTeleportation ? "§aEnabled" : "§cDisabled")));
                                    context.getSource().sendFeedback(Text.literal("§7Max Distance Per Packet: §e" +
                                            Zipline.CONFIG.maxDistancePerPacket + " blocks"));
                                    context.getSource().sendFeedback(Text.literal("§7Packet Delay: §e" +
                                            Zipline.CONFIG.packetDelayMs + "ms"));
                                    context.getSource().sendFeedback(Text.literal("§7Chunk Poll Interval: §e" +
                                            Zipline.CONFIG.chunkLoadPollIntervalMs + "ms"));
                                    return 1;
                                })
                        )
                )
        );
    }

    private void executePathfinding(BlockPos targetPos, FabricClientCommandSource source) {
        source.sendFeedback(Text.literal("§aCalculating path to " + targetPos.getX() + ", " +
                targetPos.getY() + ", " + targetPos.getZ() + "..."));

        // Run path calculation in a separate thread to avoid blocking the game
        CompletableFuture.supplyAsync(() -> baritoneIntegration.calculatePath(targetPos))
                .thenAccept(path -> {
                    if (path.isEmpty()) {
                        source.sendFeedback(Text.literal("§cCould not calculate a path to the target"));
                        return;
                    }

                    source.sendFeedback(Text.literal("§aPath calculated with " + path.size() + " nodes"));

                    // Execute the path
                    Zipline.EXECUTOR.executePath(path)
                            .thenRun(() -> source.sendFeedback(Text.literal("§aReached destination!")))
                            .exceptionally(e -> {
                                source.sendFeedback(Text.literal("§cFailed to execute path: " + e.getMessage()));
                                return null;
                            });
                });
    }
}

================
File: src/main/java/com/claude/config/ModConfig.java
================
// src/main/java/com/claude/config/ModConfig.java
package com.claude.config;

/**
 * Configuration settings for the Zipline mod
 */
public class ModConfig {
    // Core functionality switches
    public boolean useTeleportation = true;
    public boolean fallbackToNormal = true;

    // Teleportation settings
    public double maxDistancePerPacket = 10.0;
    public int packetDelayMs = 50;

    // Chunk loading settings
    public int chunkLoadPollIntervalMs = 200;
    public int maxWaitForChunkLoadMs = 5000;

    // Fallback settings
    public int maxFailedTeleportAttempts = 3;
    public int resumeTeleportAfterBlocksMs = 2000;
}

================
File: src/main/java/com/claude/mixin/ClientNetworkHandlerMixin.java
================
// src/main/java/com/claude/mixin/ClientNetworkHandlerMixin.java
package com.claude.mixin;

import com.claude.Zipline;
import net.minecraft.client.network.ClientPlayNetworkHandler;
import net.minecraft.network.packet.s2c.play.ChunkDataS2CPacket;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(ClientPlayNetworkHandler.class)
public class ClientNetworkHandlerMixin {
	/**
	 * Hook into chunk data receiving to improve chunk load detection
	 */
	@Inject(method = "onChunkData", at = @At("RETURN"))
	private void onChunkDataPacket(ChunkDataS2CPacket packet, CallbackInfo ci) {
		// We can use this to notify our executor about newly loaded chunks
		// This is just a hook point, implementation would depend on optimizations needed
		Zipline.LOGGER.debug("Chunk loaded at {}, {}", packet.getX(), packet.getZ());
	}
}

================
File: src/main/java/com/claude/pathfinding/BaritoneIntegration.java
================
// src/main/java/com/claude/pathfinding/BaritoneIntegration.java
package com.claude.pathfinding;

import baritone.api.BaritoneAPI;
import baritone.api.IBaritone;
import baritone.api.pathing.goals.Goal;
import baritone.api.pathing.goals.GoalBlock;
import baritone.api.process.ICustomGoalProcess;
import baritone.api.process.IPathingControlManager;
import com.claude.Zipline;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class BaritoneIntegration {
    private final IBaritone baritone;

    public BaritoneIntegration() {
        this.baritone = BaritoneAPI.getProvider().getPrimaryBaritone();
    }

    /**
     * Calculate a path to the target position using Baritone
     *
     * @param target Target position
     * @return List of path positions, or empty if path calculation failed
     */
    public List<BlockPos> calculatePath(BlockPos target) {
        List<BlockPos> path = new ArrayList<>();

        try {
            // Set goal in Baritone
            Goal goal = new GoalBlock(target);
            IPathingControlManager pathingControlManager = baritone.getPathingControlManager();
            ICustomGoalProcess customGoalProcess = baritone.getCustomGoalProcess();

            // Start path calculation
            customGoalProcess.setGoalAndPath(goal);

            // Wait for path calculation to complete
            long startTime = System.currentTimeMillis();
            while (!customGoalProcess.isActive() && System.currentTimeMillis() - startTime < 5000) {
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    Zipline.LOGGER.error("Interrupted while waiting for path calculation", e);
                    return path;
                }
            }

            // Get current path from Baritone
            Optional<BlockPos> pathPosition = Optional.empty();
            if (baritone.getPathingBehavior().isPathing() &&
                    baritone.getPathingBehavior().getCurrent() != null &&
                    baritone.getPathingBehavior().getCurrent().getPath() != null) {

                // Extract positions from Baritone's path
                baritone.getPathingBehavior().getCurrent().getPath().positions().forEach(bpos -> {
                    path.add(new BlockPos(bpos.x, bpos.y, bpos.z));
                });
            }

            // Cancel Baritone's active pathing to avoid conflicts
            baritone.getPathingBehavior().cancelEverything();

        } catch (Exception e) {
            Zipline.LOGGER.error("Error calculating path with Baritone", e);
        }

        return path;
    }

    /**
     * Stop any active Baritone processes
     */
    public void stopBaritoneProcesses() {
        baritone.getPathingBehavior().cancelEverything();
    }
}

================
File: src/main/java/com/claude/pathfinding/TeleportPathExecutor.java
================
// src/main/java/com/claude/pathfinding/TeleportPathExecutor.java
package com.claude.pathfinding;

import com.claude.Zipline;
import com.claude.ui.TeleportHud;
import com.claude.world.ChunkLoadingTracker;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.network.packet.c2s.play.PlayerMoveC2SPacket;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.Vec3d;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;

public class TeleportPathExecutor {
    private final MinecraftClient client = MinecraftClient.getInstance();
    private final AtomicBoolean isExecutingPath = new AtomicBoolean(false);
    private int failedAttempts = 0;
    private BlockPos lastPosition = null;
    private long lastTeleportTime = 0;
    private final TeleportHud hud;
    private final ChunkLoadingTracker chunkTracker;

    public TeleportPathExecutor() {
        this.hud = new TeleportHud();
        this.chunkTracker = new ChunkLoadingTracker();
    }

    /**
     * Execute teleportation along the given path
     *
     * @param path List of positions to traverse
     * @return CompletableFuture that completes when the path execution is done
     */
    public CompletableFuture<Void> executePath(List<BlockPos> path) {
        CompletableFuture<Void> future = new CompletableFuture<>();

        if (!Zipline.CONFIG.useTeleportation) {
            future.completeExceptionally(new IllegalStateException("Teleportation mode is disabled"));
            return future;
        }

        if (isExecutingPath.getAndSet(true)) {
            future.completeExceptionally(new IllegalStateException("Already executing a path"));
            return future;
        }

        CompletableFuture.runAsync(() -> {
            try {
                executePathInternal(path);
                future.complete(null);
            } catch (Exception e) {
                Zipline.LOGGER.error("Error during path execution", e);
                future.completeExceptionally(e);
            } finally {
                isExecutingPath.set(false);
            }
        });

        return future;
    }

    /**
     * Internal method to execute the path
     */
    private void executePathInternal(List<BlockPos> path) throws InterruptedException {
        ClientPlayerEntity player = client.player;
        if (player == null) return;

        failedAttempts = 0;
        lastPosition = new BlockPos(player.getX(), player.getY(), player.getZ());

        int totalNodes = path.size();

        for (int i = 0; i < path.size(); i++) {
            BlockPos targetPos = path.get(i);

            // Update HUD
            hud.updatePathProgress(i, totalNodes, targetPos);

            // Check if teleportation is still enabled
            if (!Zipline.CONFIG.useTeleportation) {
                Zipline.LOGGER.info("Teleportation disabled during path execution");
                return;
            }

            // Check if we're at the end of the path
            if (i == path.size() - 1) {
                teleportToPosition(targetPos);
                break;
            }

            // Calculate steps needed based on max distance
            Vec3d currentPos = new Vec3d(player.getX(), player.getY(), player.getZ());
            Vec3d targetVec = new Vec3d(targetPos.getX() + 0.5, targetPos.getY(), targetPos.getZ() + 0.5);
            double distance = currentPos.distanceTo(targetVec);

            if (distance <= Zipline.CONFIG.maxDistancePerPacket) {
                if (teleportToPosition(targetPos)) {
                    lastPosition = targetPos;
                } else if (failedAttempts >= Zipline.CONFIG.maxFailedTeleportAttempts) {
                    // Too many failures, fall back to normal movement if configured
                    if (Zipline.CONFIG.fallbackToNormal) {
                        Zipline.LOGGER.warn("Falling back to normal movement due to teleport failures");
                        fallBackToNormalMovement(targetPos);

                        // Wait before attempting to resume teleportation
                        Thread.sleep(Zipline.CONFIG.resumeTeleportAfterBlocksMs);
                        failedAttempts = 0;
                    }
                }
            } else {
                // Split into smaller steps
                int steps = (int) Math.ceil(distance / Zipline.CONFIG.maxDistancePerPacket);
                for (int step = 1; step <= steps; step++) {
                    double progress = (double) step / steps;
                    Vec3d intermediatePos = currentPos.lerp(targetVec, progress);
                    BlockPos intermediateBlockPos = new BlockPos((int)intermediatePos.x, (int)intermediatePos.y, (int)intermediatePos.z);

                    if (teleportToPosition(intermediateBlockPos)) {
                        lastPosition = intermediateBlockPos;
                    } else if (failedAttempts >= Zipline.CONFIG.maxFailedTeleportAttempts) {
                        if (Zipline.CONFIG.fallbackToNormal) {
                            Zipline.LOGGER.warn("Falling back to normal movement due to teleport failures");
                            fallBackToNormalMovement(targetPos);

                            // Wait before attempting to resume teleportation
                            Thread.sleep(Zipline.CONFIG.resumeTeleportAfterBlocksMs);
                            failedAttempts = 0;
                        }
                        break;
                    }
                }
            }

            // Apply packet delay between steps
            Thread.sleep(Zipline.CONFIG.packetDelayMs);
        }
    }

    /**
     * Teleport to a specific position, handling chunk loading
     *
     * @param pos Target position
     * @return true if teleport was successful, false otherwise
     */
    private boolean teleportToPosition(BlockPos pos) throws InterruptedException {
        ClientPlayerEntity player = client.player;
        if (player == null) return false;

        // Check if the chunk is loaded
        ChunkPos chunkPos = new ChunkPos(pos);
        if (!chunkTracker.isChunkLoaded(chunkPos)) {
            Zipline.LOGGER.info("Waiting for chunk at {} to load", chunkPos);

            long startWaitTime = System.currentTimeMillis();
            while (!chunkTracker.isChunkLoaded(chunkPos)) {
                Thread.sleep(Zipline.CONFIG.chunkLoadPollIntervalMs);

                // Check if we've waited too long
                if (System.currentTimeMillis() - startWaitTime > Zipline.CONFIG.maxWaitForChunkLoadMs) {
                    Zipline.LOGGER.warn("Chunk load timeout for {}", ch

================
File: src/main/java/com/claude/ui/TeleportHud.java
================
// src/main/java/com/claude/ui/TeleportHud.java
package com.claude.ui;

import com.claude.Zipline;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.text.Text;
import net.minecraft.util.math.BlockPos;

public class TeleportHud implements HudRenderCallback {
    private final MinecraftClient client = MinecraftClient.getInstance();
    private long lastPathProgress = 0;
    private int totalPathNodes = 0;
    private int currentPathNode = 0;
    private BlockPos currentTarget = null;

    public TeleportHud() {
        HudRenderCallback.EVENT.register(this);
    }

    @Override
    public void onHudRender(DrawContext drawContext, float tickDelta) {
        if (!Zipline.CONFIG.useTeleportation || !Zipline.EXECUTOR.isExecuting()) {
            return;
        }

        TextRenderer textRenderer = client.textRenderer;

        // Draw background
        int width = 150;
        int height = 65;
        int x = 5;
        int y = 5;

        drawContext.fill(x, y, x + width, y + height, 0x80000000);

        // Draw title
        drawContext.drawText(textRenderer, Text.literal("§b§lZipline Status"), x + 5, y + 5, 0xFFFFFF, false);

        // Draw info
        drawContext.drawText(
                textRenderer,
                Text.literal("§7Status: " + (Zipline.EXECUTOR.isExecuting() ? "§aActive" : "§cInactive")),
                x + 5, y + 20, 0xFFFFFF, false
        );

        drawContext.drawText(
                textRenderer,
                Text.literal("§7Mode: " + (Zipline.CONFIG.useTeleportation ? "§aTeleport" : "§eNormal")),
                x + 5, y + 35, 0xFFFFFF, false
        );

        if (Zipline.EXECUTOR.isExecuting() && currentTarget != null) {
            drawContext.drawText(
                    textRenderer,
                    Text.literal("§7Progress: §e" + currentPathNode + "/" + totalPathNodes),
                    x + 5, y + 50, 0xFFFFFF, false
            );
        }
    }

    public void updatePathProgress(int current, int total, BlockPos target) {
        this.currentPathNode = current;
        this.totalPathNodes = total;
        this.currentTarget = target;
        this.lastPathProgress = System.currentTimeMillis();
    }
}

================
File: src/main/java/com/claude/world/ChunkLoadingTracker.java
================
// src/main/java/com/claude/world/ChunkLoadingTracker.java
package com.claude.world;

import com.claude.Zipline;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientChunkEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.math.ChunkSectionPos;
import net.minecraft.world.chunk.WorldChunk;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Tracks loaded chunks on the client side for more efficient pathfinding
 */
public class ChunkLoadingTracker {
    private final Set<ChunkPos> loadedChunks = Collections.newSetFromMap(new ConcurrentHashMap<>());
    private final MinecraftClient client = MinecraftClient.getInstance();

    public ChunkLoadingTracker() {
        registerEvents();
    }

    private void registerEvents() {
        // Register chunk load events
        ClientChunkEvents.CHUNK_LOAD.register((world, chunk) -> {
            ChunkPos pos = chunk.getPos();
            loadedChunks.add(pos);
            Zipline.LOGGER.debug("Chunk loaded at {}, {}", pos.x, pos.z);
        });

        // Register chunk unload events
        ClientChunkEvents.CHUNK_UNLOAD.register((world, chunk) -> {
            ChunkPos pos = chunk.getPos();
            loadedChunks.remove(pos);
            Zipline.LOGGER.debug("Chunk unloaded at {}, {}", pos.x, pos.z);
        });
    }

    /**
     * Check if a chunk is loaded
     *
     * @param pos ChunkPos to check
     * @return true if the chunk is loaded, false otherwise
     */
    public boolean isChunkLoaded(ChunkPos pos) {
        // First check our cache for quick lookups
        if (loadedChunks.contains(pos)) {
            return true;
        }

        // Double-check with actual chunk data if needed
        if (client.world != null) {
            WorldChunk chunk = client.world.getChunkManager().getWorldChunk(pos.x, pos.z, false);
            boolean isLoaded = chunk != null && !chunk.isEmpty();

            // Update our cache if we found a loaded chunk
            if (isLoaded) {
                loadedChunks.add(pos);
            }

            return isLoaded;
        }

        return false;
    }

    /**
     * Check if all chunks in a range around a position are loaded
     *
     * @param center Center position
     * @param radius Radius in chunks
     * @return true if all chunks in range are loaded, false otherwise
     */
    public boolean areChunksLoadedInRadius(ChunkPos center, int radius) {
        for (int x = center.x - radius; x <= center.x + radius; x++) {
            for (int z = center.z - radius; z <= center.z + radius; z++) {
                ChunkPos pos = new ChunkPos(x, z);
                if (!isChunkLoaded(pos)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Get a set of all currently loaded chunks
     *
     * @return Set of loaded chunk positions
     */
    public Set<ChunkPos> getLoadedChunks() {
        return new HashSet<>(loadedChunks);
    }

    /**
     * Clear the tracker cache (e.g., when changing dimensions)
     */
    public void clearCache() {
        loadedChunks.clear();
    }
}

================
File: src/main/java/com/claude/Zipline.java
================
// src/main/java/com/claude/Zipline.java
package com.claude;

import com.claude.commands.CommandHandler;
import com.claude.config.ModConfig;
import com.claude.pathfinding.TeleportPathExecutor;
import net.fabricmc.api.ModInitializer;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import org.lwjgl.glfw.GLFW;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Zipline implements ModInitializer {
	public static final String MOD_ID = "zipline";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	public static ModConfig CONFIG;
	public static TeleportPathExecutor EXECUTOR;

	private KeyBinding toggleTeleportKey;
	private KeyBinding teleportToTargetKey;
	private CommandHandler commandHandler;

	@Override
	public void onInitialize() {
		LOGGER.info("Initializing Zipline - Baritone Teleport Pathfinding");

		// Initialize configuration
		CONFIG = new ModConfig();

		// Initialize teleport executor
		EXECUTOR = new TeleportPathExecutor();

		// Register commands
		commandHandler = new CommandHandler();

		// Register keybindings
		registerKeybinds();

		LOGGER.info("Zipline initialization complete!");
	}

	private void registerKeybinds() {
		toggleTeleportKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.zipline.toggle_teleport",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_J,
				"category.zipline.keys"
		));

		teleportToTargetKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.zipline.teleport_to_target",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_K,
				"category.zipline.keys"
		));

		// Register client tick event for keybind handling
		ClientTickEvents.END_CLIENT_TICK.register(client -> {
			if (toggleTeleportKey.wasPressed()) {
				CONFIG.useTeleportation = !CONFIG.useTeleportation;
				if (CONFIG.useTeleportation) {
					LOGGER.info("Teleportation mode enabled");
					if (client.player != null) {
						client.player.sendMessage(net.minecraft.text.Text.literal("§aTeleportation mode enabled"), true);
					}
				} else {
					LOGGER.info("Teleportation mode disabled");
					if (client.player != null) {
						client.player.sendMessage(net.minecraft.text.Text.literal("§cTeleportation mode disabled"), true);
					}
				}
			}

			// Handle teleport to target key - can be used to trigger teleportation to where you're looking
			if (teleportToTargetKey.wasPressed() && client.crosshairTarget != null &&
					client.crosshairTarget.getType() == net.minecraft.util.hit.HitResult.Type.BLOCK) {

				net.minecraft.util.hit.BlockHitResult blockHit = (net.minecraft.util.hit.BlockHitResult) client.crosshairTarget;
				net.minecraft.util.math.BlockPos targetPos = blockHit.getBlockPos();

				// Only proceed if we have a valid target and are not already executing
				if (!EXECUTOR.isExecuting()) {
					if (client.player != null) {
						client.player.sendMessage(net.minecraft.text.Text.literal("§aTeleporting to target block..."), true);
					}

					// Get the Baritone path and execute it
					com.claude.pathfinding.BaritoneIntegration baritone = new com.claude.pathfinding.BaritoneIntegration();
					java.util.List<net.minecraft.util.math.BlockPos> path = baritone.calculatePath(targetPos);

					if (!path.isEmpty()) {
						EXECUTOR.executePath(path)
								.thenRun(() -> {
									if (client.player != null) {
										client.player.sendMessage(net.minecraft.text.Text.literal("§aReached destination!"), true);
									}
								})
								.exceptionally(e -> {
									if (client.player != null) {
										client.player.sendMessage(
												net.minecraft.text.Text.literal("§cFailed to execute path: " + e.getMessage()),
												true
										);
									}
									return null;
								});
					} else {
						if (client.player != null) {
							client.player.sendMessage(net.minecraft.text.Text.literal("§cCould not calculate a path to the target"), true);
						}
					}
				}
			}
		});
	}
}

================
File: src/main/resources/fabric.mod.json
================
{
	"schemaVersion": 1,
	"id": "zipline",
	"version": "1.0.0",
	"name": "Zipline",
	"description": "Baritone teleport pathfinding using movement packets",
	"authors": [
		"Claude"
	],
	"contact": {
		"homepage": "https://example.com",
		"sources": "https://github.com/example/zipline"
	},
	"license": "MIT",
	"icon": "assets/zipline/icon.png",
	"environment": "client",
	"entrypoints": {
		"main": [
			"com.claude.Zipline"
		]
	},
	"mixins": [
		"zipline.mixins.json"
	],
	"depends": {
		"fabricloader": ">=0.14.21",
		"fabric": "*",
		"minecraft": "~1.21",
		"java": ">=17",
		"baritone": "*"
	},
	"suggests": {
		"another-mod": "*"
	}
}

================
File: src/main/resources/zipline.mixins.json
================
{
	"required": true,
	"minVersion": "0.8",
	"package": "com.claude.mixin",
	"compatibilityLevel": "JAVA_17",
	"mixins": [
	],
	"client": [
		"ClientNetworkHandlerMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}

================
File: .gitattributes
================
#
# https://help.github.com/articles/dealing-with-line-endings/
#
# Linux start script should use lf
/gradlew        text eol=lf

# These are Windows script files and should use crlf
*.bat           text eol=crlf

================
File: .gitignore
================
# gradle

.gradle/
build/
out/
classes/

# eclipse

*.launch

# idea

.idea/
*.iml
*.ipr
*.iws

# vscode

.settings/
.vscode/
bin/
.classpath
.project

# macos

*.DS_Store

# fabric

run/

# java

hs_err_*.log
replay_*.log
*.hprof
*.jfr

================
File: build.gradle
================
plugins {
	id 'fabric-loom' version '1.3-SNAPSHOT'
	id 'maven-publish'
}

version = project.mod_version
group = project.maven_group

repositories {
	maven {
		name = "Baritone"
		url = "https://maven.fabricmc.net/"
	}
}

dependencies {
	// Minecraft
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.minecraft_version}+build.${project.yarn_build}:v2"
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"

	// Fabric API
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}"

	// Baritone API - Implementation will vary based on Baritone's distribution method for 1.21+
	// Below is a placeholder, actual implementation may differ
	modImplementation "cabaletta:baritone-api:1.9"
	include "cabaletta:baritone-api:1.9" // This may change based on Baritone's actual distribution
}

processResources {
	inputs.property "version", project.version

	filesMatching("fabric.mod.json") {
		expand "version": project.version
	}
}

tasks.withType(JavaCompile).configureEach {
	it.options.encoding = "UTF-8"
	it.options.release = 17
}

java {
	withSourcesJar()
}

jar {
	from("LICENSE")
}

// Publishing configuration
publishing {
	publications {
		mavenJava(MavenPublication) {
			artifact(remapJar) {
				builtBy remapJar
			}
			artifact(sourcesJar) {
				builtBy remapSourcesJar
			}
		}
	}

	repositories {
		// Add repositories for publishing if needed
	}
}

================
File: gradle.properties
================
# Done to increase the memory available to gradle.
org.gradle.jvmargs=-Xmx2G
org.gradle.parallel=true

# Fabric Properties
minecraft_version=1.21
yarn_build=1
loader_version=0.15.6

# Mod Properties
mod_version=1.0.0
maven_group=com.claude
archives_base_name=zipline

# Dependencies
fabric_version=0.91.0+1.21

================
File: gradlew
================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s\n' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"

================
File: gradlew.bat
================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

================
File: LICENSE
================
Creative Commons Legal Code

CC0 1.0 Universal

    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE
    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN
    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS
    INFORMATION ON AN "AS-IS" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES
    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS
    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM
    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED
    HEREUNDER.

Statement of Purpose

The laws of most jurisdictions throughout the world automatically confer
exclusive Copyright and Related Rights (defined below) upon the creator
and subsequent owner(s) (each and all, an "owner") of an original work of
authorship and/or a database (each, a "Work").

Certain owners wish to permanently relinquish those rights to a Work for
the purpose of contributing to a commons of creative, cultural and
scientific works ("Commons") that the public can reliably and without fear
of later claims of infringement build upon, modify, incorporate in other
works, reuse and redistribute as freely as possible in any form whatsoever
and for any purposes, including without limitation commercial purposes.
These owners may contribute to the Commons to promote the ideal of a free
culture and the further production of creative, cultural and scientific
works, or to gain reputation or greater distribution for their Work in
part through the use and efforts of others.

For these and/or other purposes and motivations, and without any
expectation of additional consideration or compensation, the person
associating CC0 with a Work (the "Affirmer"), to the extent that he or she
is an owner of Copyright and Related Rights in the Work, voluntarily
elects to apply CC0 to the Work and publicly distribute the Work under its
terms, with knowledge of his or her Copyright and Related Rights in the
Work and the meaning and intended legal effect of CC0 on those rights.

1. Copyright and Related Rights. A Work made available under CC0 may be
protected by copyright and related or neighboring rights ("Copyright and
Related Rights"). Copyright and Related Rights include, but are not
limited to, the following:

  i. the right to reproduce, adapt, distribute, perform, display,
     communicate, and translate a Work;
 ii. moral rights retained by the original author(s) and/or performer(s);
iii. publicity and privacy rights pertaining to a person's image or
     likeness depicted in a Work;
 iv. rights protecting against unfair competition in regards to a Work,
     subject to the limitations in paragraph 4(a), below;
  v. rights protecting the extraction, dissemination, use and reuse of data
     in a Work;
 vi. database rights (such as those arising under Directive 96/9/EC of the
     European Parliament and of the Council of 11 March 1996 on the legal
     protection of databases, and under any national implementation
     thereof, including any amended or successor version of such
     directive); and
vii. other similar, equivalent or corresponding rights throughout the
     world based on applicable law or treaty, and any national
     implementations thereof.

2. Waiver. To the greatest extent permitted by, but not in contravention
of, applicable law, Affirmer hereby overtly, fully, permanently,
irrevocably and unconditionally waives, abandons, and surrenders all of
Affirmer's Copyright and Related Rights and associated claims and causes
of action, whether now known or unknown (including existing as well as
future claims and causes of action), in the Work (i) in all territories
worldwide, (ii) for the maximum duration provided by applicable law or
treaty (including future time extensions), (iii) in any current or future
medium and for any number of copies, and (iv) for any purpose whatsoever,
including without limitation commercial, advertising or promotional
purposes (the "Waiver"). Affirmer makes the Waiver for the benefit of each
member of the public at large and to the detriment of Affirmer's heirs and
successors, fully intending that such Waiver shall not be subject to
revocation, rescission, cancellation, termination, or any other legal or
equitable action to disrupt the quiet enjoyment of the Work by the public
as contemplated by Affirmer's express Statement of Purpose.

3. Public License Fallback. Should any part of the Waiver for any reason
be judged legally invalid or ineffective under applicable law, then the
Waiver shall be preserved to the maximum extent permitted taking into
account Affirmer's express Statement of Purpose. In addition, to the
extent the Waiver is so judged Affirmer hereby grants to each affected
person a royalty-free, non transferable, non sublicensable, non exclusive,
irrevocable and unconditional license to exercise Affirmer's Copyright and
Related Rights in the Work (i) in all territories worldwide, (ii) for the
maximum duration provided by applicable law or treaty (including future
time extensions), (iii) in any current or future medium and for any number
of copies, and (iv) for any purpose whatsoever, including without
limitation commercial, advertising or promotional purposes (the
"License"). The License shall be deemed effective as of the date CC0 was
applied by Affirmer to the Work. Should any part of the License for any
reason be judged legally invalid or ineffective under applicable law, such
partial invalidity or ineffectiveness shall not invalidate the remainder
of the License, and in such case Affirmer hereby affirms that he or she
will not (i) exercise any of his or her remaining Copyright and Related
Rights in the Work or (ii) assert any associated claims and causes of
action with respect to the Work, in either case contrary to Affirmer's
express Statement of Purpose.

4. Limitations and Disclaimers.

 a. No trademark or patent rights held by Affirmer are waived, abandoned,
    surrendered, licensed or otherwise affected by this document.
 b. Affirmer offers the Work as-is and makes no representations or
    warranties of any kind concerning the Work, express, implied,
    statutory or otherwise, including without limitation warranties of
    title, merchantability, fitness for a particular purpose, non
    infringement, or the absence of latent or other defects, accuracy, or
    the present or absence of errors, whether or not discoverable, all to
    the greatest extent permissible under applicable law.
 c. Affirmer disclaims responsibility for clearing rights of other persons
    that may apply to the Work or any use thereof, including without
    limitation any person's Copyright and Related Rights in the Work.
    Further, Affirmer disclaims responsibility for obtaining any necessary
    consents, permissions or other rights required for any use of the
    Work.
 d. Affirmer understands and acknowledges that Creative Commons is not a
    party to this document and has no duty or obligation with respect to
    this CC0 or use of the Work.

================
File: settings.gradle
================
pluginManagement {
	repositories {
		maven {
			name = 'Fabric'
			url = 'https://maven.fabricmc.net/'
		}
		mavenCentral()
		gradlePluginPortal()
	}
}
